package org.talend.geat;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.jboss.aesh.cl.Arguments;
import org.jboss.aesh.cl.CommandDefinition;
import org.jboss.aesh.cl.Option;
import org.jboss.aesh.cl.OptionList;
import org.jboss.aesh.cl.activation.OptionActivator;
import org.jboss.aesh.cl.completer.OptionCompleter;
import org.jboss.aesh.cl.internal.ProcessedCommand;
import org.jboss.aesh.cl.internal.ProcessedOption;
import org.jboss.aesh.cl.renderer.OptionRenderer;
import org.jboss.aesh.console.AeshConsole;
import org.jboss.aesh.console.AeshConsoleBuilder;
import org.jboss.aesh.console.Prompt;
import org.jboss.aesh.console.command.Command;
import org.jboss.aesh.console.command.CommandResult;
import org.jboss.aesh.console.command.completer.CompleterInvocation;
import org.jboss.aesh.console.command.invocation.CommandInvocation;
import org.jboss.aesh.console.command.registry.MutableCommandRegistry;
import org.jboss.aesh.console.settings.Settings;
import org.jboss.aesh.console.settings.SettingsBuilder;
import org.jboss.aesh.terminal.CharacterType;
import org.jboss.aesh.terminal.Color;
import org.jboss.aesh.terminal.TerminalColor;
import org.jboss.aesh.terminal.TerminalTextStyle;

public class TestAesh {

    public static void main(String[] args) {

        Settings settings = new SettingsBuilder().logging(true).create();
        MutableCommandRegistry commandRegistry = new MutableCommandRegistry();
        commandRegistry.addCommand(ExitCommand.class);
        commandRegistry.addCommand(LsCommand.class);
        commandRegistry.addCommand(TestCommand.class);

        AeshConsole aeshConsole = new AeshConsoleBuilder().settings(settings).prompt(new Prompt("[aesh@rules]$ "))
                .commandRegistry(commandRegistry).create();

        aeshConsole.start();
    }

    @CommandDefinition(name = "exit", description = "exit the program")
    public static class ExitCommand implements Command {
        public CommandResult execute(CommandInvocation invocation) {
            invocation.stop();
            return CommandResult.SUCCESS;
        }
    }

    @CommandDefinition(name = "ll", description = "fooing")
    public static class LsCommand implements Command {

        @Arguments
        private List<File> files;

        public CommandResult execute(CommandInvocation invocation) {
            if (files != null) {
                for (File f : files)
                    invocation.getShell().out().println(f.toString());
            }
            return CommandResult.SUCCESS;
        }
    }

    @CommandDefinition(name = "ls", description = "[OPTION]... [FILE]...")
    public static class TestCommand implements Command {

        @Option(shortName = 'f', hasValue = false, description = "set foo to true/false")
        private Boolean    foo;

        @Option(hasValue = false, description = "set the bar", renderer = BlueBoldRenderer.class)
        private boolean    bar;

        @Option(completer = TestCompleter.class, defaultValue = { "MORE" }, argument = "SIZE")
        private String     less;

        @OptionList(defaultValue = "/tmp", description = "file location", valueSeparator = ':', activator = BarActivator.class)
        List<File>         files;

        @Option(hasValue = false, description = "display this help and exit")
        private boolean    help;

        @Arguments
        private List<File> arguments;

        public CommandResult execute(CommandInvocation commandInvocation) throws IOException {
            if (help) {
                commandInvocation.getShell().out().println(commandInvocation.getHelpInfo("ls"));
            } else {
                if (foo)
                    commandInvocation.getShell().out().println("you set foo to: " + foo);
                if (bar)
                    commandInvocation.getShell().out().println("you set bar to: " + bar);
                if (less != null)
                    commandInvocation.getShell().out().println("you set less to: " + less);
                if (files != null)
                    commandInvocation.getShell().out().println("you set file to: " + files);

                if (arguments != null) {
                    for (File f : arguments)
                        commandInvocation.getShell().out().println(f.toString());
                }
            }
            return CommandResult.SUCCESS;
        }
    }

    public static class TestCompleter implements OptionCompleter {

        public void complete(CompleterInvocation completerData) {
            List<String> completeList = new ArrayList<String>();
            if (completerData.getGivenCompleteValue() == null || completerData.getGivenCompleteValue().length() == 0)
                completeList.add("1");
            else {
                char lastChar = completerData.getGivenCompleteValue().charAt(
                        completerData.getGivenCompleteValue().length() - 1);
                if (Character.isDigit(lastChar)) {
                    int i = (int) lastChar;
                    i++;
                    completeList.add(completerData.getGivenCompleteValue() + i);
                }
            }
        }
    }

    public static class BarActivator implements OptionActivator {

        public boolean isActivated(ProcessedCommand processedCommand) {
            ProcessedOption bar = processedCommand.findLongOption("bar");
            if (bar != null && bar.getValue() != null)
                return true;
            else
                return false;
        }
    }

    public static class BlueBoldRenderer implements OptionRenderer {

        private static TerminalTextStyle style = new TerminalTextStyle(CharacterType.UNDERLINE);

        private static TerminalColor     color = new TerminalColor(42, Color.DEFAULT);

        public TerminalColor getColor() {
            return color;
        }

        public TerminalTextStyle getTextType() {
            return style;
        }
    }
}
